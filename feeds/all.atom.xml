<?xml version="1.0" encoding="utf-8"?> 
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
 <title type="text">My Awesome Blog: My Awesome Blog</title>
 <link rel="self" href="http://www.example.com/feeds/all.atom.xml" />
 <link href="http://www.example.com/index.html" />
 <id>urn:http-www-example-com:-index-html</id>
 <updated>2015-04-12T01:53:16Z</updated>
 <entry>
  <title type="text">20% Project update</title>
  <link rel="alternate" href="http://www.example.com/blog/2015/04/11/20-project-update/?utm_source=all&amp;utm_medium=Atom" />
  <id>urn:http-www-example-com:-blog-2015-04-11-20-project-update</id>
  <published>2015-04-12T01:53:16Z</published>
  <updated>2015-04-12T01:53:16Z</updated>
  <author>
   <name>The Unknown Author</name></author>
  <content type="html">
&lt;p&gt;Euler discovered the remarkable quadratic formula:&lt;/p&gt;

&lt;p&gt;n² + n + 41&lt;/p&gt;

&lt;p&gt;It turns out that the formula will produce 40 primes for the consecutive values n = 0 to 39. However, when n = 40, 402 + 40 + 41 = 40(40 + 1) + 41 is divisible by 41, and certainly when n = 41, 41² + 41 + 41 is clearly divisible by 41.&lt;/p&gt;

&lt;p&gt;The incredible formula n² − 79n + 1601 was discovered, which produces 80 primes for the consecutive values n = 0 to 79. The product of the coefficients, −79 and 1601, is −126479.&lt;/p&gt;

&lt;p&gt;Considering quadratics of the form:&lt;/p&gt;

&lt;p&gt;n² + an + b, where |a| &amp;lt; 1000 and |b| &amp;lt; 1000&lt;/p&gt;

&lt;p&gt;where |n| is the modulus/absolute value of n e.g. |11| = 11 and |−4| = 4&lt;/p&gt;

&lt;p&gt;Find the product of the coefficients, a and b, for the quadratic expression that produces the maximum number of primes for consecutive values of n, starting with n = 0.&lt;/p&gt;

&lt;p&gt;From Project Euler&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Initially I planned to tackle this problem from a strictly brute force perspective. I have found that working on a simple solution to a problem usually gives me insights to more elegant solutions.&lt;/p&gt;

&lt;p&gt;Therefore I figured that the most straight forward and inelegant method was to produce a 1999 by 1999 array with individual elements of the array corresponding to the maximum number of consecutive primes generated by that combination of a and b.&lt;/p&gt;

&lt;p&gt;Thus the initial element of the array in position |1,1| would be the maximum number of consecutive primes generated by n² + (&amp;ndash;999)n + (&amp;ndash;999), and the final position of |1999,1999| would be n² + (999)n + (999).&lt;/p&gt;

&lt;p&gt;With this plan in mind I tried to think up a quick way to calculate the maximum number of consecutive primes for a given a and b.&lt;/p&gt;

&lt;p&gt;I started by having Mathematica generate the first 101 values from the example given in the problem by using a=1 and b=41.&lt;/p&gt;

&lt;p&gt;ProjectEuler-Mathematica01&lt;/p&gt;

&lt;p&gt;I then used PrimeQ to test whether each value was prime.&lt;/p&gt;

&lt;p&gt;ProjectEuler-Mathematica02&lt;/p&gt;

&lt;p&gt;Then used Boole to convert these true false values to 0&amp;rsquo;s and 1&amp;rsquo;s.&lt;/p&gt;

&lt;p&gt;ProjectEuler-Mathematica03&lt;/p&gt;

&lt;p&gt;And finally FirstPosition to find the first false in the list.&lt;/p&gt;

&lt;p&gt;ProjectEuler-Mathematica04&lt;/p&gt;

&lt;p&gt;Note that the answer of 41 corresponds to the 39 primes listed in the example since this method doesn&amp;rsquo;t count the primes from 0&amp;ndash;39 but from 1&amp;ndash;40 and it found a non-Prime number in position 41.&lt;/p&gt;

&lt;p&gt;So&amp;hellip;&lt;/p&gt;

&lt;p&gt;This method is horribly inelegant, however it also does work so it&amp;rsquo;s time to see if I can use this method to generate the 1999 by 1999 array I initially planned for.&lt;/p&gt;

&lt;p&gt;I begin by trying a smaller array and seeing if my method works.&lt;/p&gt;

&lt;p&gt;ProjectEuler-Mathematica05&lt;/p&gt;

&lt;p&gt;Note that this entry should be much larger as it displays a 51 by 51 array of values.&lt;/p&gt;

&lt;p&gt;To find the maximum element of this array I then use the Position and Max commands. Position gives the location in an array of a specified value, and Max gives the largest element of the array.&lt;/p&gt;

&lt;p&gt;ProjectEuler-Mathematica06&lt;/p&gt;

&lt;p&gt;Since we are counting up from 0 we have now found that the Maximum number of consecutive primes is generated with a=1 and b=41 which matches the example.&lt;/p&gt;

&lt;p&gt;One area of concern going forward is that it takes 0.655204 secs for Mathematica to create the 51 by 51 array I used above. Since a 1999 by 1999 array is nearly 1600% larger than a 50 by 50 array that means that generating a 1999 by 1999 array should take at least 17 minutes and 28.33 second. Most likely longer considering that the edges of the array will be dealing with a and b values greater than 900.&lt;/p&gt;

&lt;p&gt;Still I have free time and I&amp;rsquo;m not paying for processing time so we might as well go forward and see how long it takes.&lt;/p&gt;

&lt;p&gt;ProjectEuler-Mathematica07&lt;/p&gt;

&lt;p&gt;So 21 minutes and 14 seconds later we have our array and can try to find the Maximum number of consecutive primes.&lt;/p&gt;

&lt;p&gt;ProjectEuler-Mathematica08&lt;/p&gt;

&lt;p&gt;And we have a max at |939,1971|, so 939&amp;ndash;1000=&amp;ndash;61 and 1971&amp;ndash;1000=971 are are a and b values.&lt;/p&gt;

&lt;p&gt;a*b=&amp;ndash;61*971=&amp;ndash;59231&lt;/p&gt;

&lt;p&gt;And we thus have our answer for Problem 27.&lt;/p&gt;

&lt;p&gt;Now how could we have improved this process.&lt;/p&gt;

&lt;p&gt;We could start by recognizing that b has to be a prime number. It was only after I had finished this problem that I realized that since n starts at 0 the first element will always be 0*0 + a*0 + b. Since there are 168 primes less than 1000 that means I only needed 168 rows instead of 1999.&lt;/p&gt;

&lt;p&gt;A 1999 by 168 array is 8.4% the size of a 1999 by 1999 array and only took Mathematica 1 minute and 56 seconds to calculate.&lt;/p&gt;

&lt;p&gt;ProjectEuler-Mathematica09&lt;/p&gt;

&lt;p&gt;A larger time sink is that I am actually calculating out the first 100 n values for every combination of a and b tested. Thus even if the second value calculated is non-Prime I still waste time evaluating the next 98 values.&lt;/p&gt;

&lt;p&gt;Using the following code I can just check if the n values are prime and stop when a non-Prime is found.&lt;/p&gt;

&lt;p&gt;ProjectEuler-Mathematica10&lt;/p&gt;

&lt;p&gt;To better understand how much time this saves, I calculated a 50 by 50 array using the old method and the new method and had Mathematica generate an ArrayPlot to save space.&lt;/p&gt;

&lt;p&gt;ProjectEuler-Mathematica11&lt;/p&gt;

&lt;p&gt;The second method took 6.1% of the time taken by the first method.&lt;/p&gt;

&lt;p&gt;Using both methods together the entire process of generating the 1999 by 168 array takes 10 seconds.&lt;/p&gt;

&lt;p&gt;ProjectEuler-Mathematica12&lt;/p&gt;

&lt;p&gt;I haven&amp;rsquo;t looked into it, but I suspect that I could similarly shave a couple of seconds off of the total running time by finding some trick for picking a values.&lt;/p&gt;

&lt;p&gt;Conclusion&lt;/p&gt;

&lt;p&gt;I started by creating a rather inelegant method for finding the number of consecutive primes generated on a 1999 by 1999 matrix. This method took 21 minutes and 14 seconds.&lt;/p&gt;

&lt;p&gt;I next examined the problem more closely and found areas that could be refined so that I found that same solution in 10 seconds.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;m confident that the majority of the improvement in performance came from optimizing the operation that found the number of consecutive primes.&lt;/p&gt;

&lt;p&gt;ProjectEuler-Mathematica13&lt;/p&gt;

&lt;p&gt;Using the above code I found that 280607 times the second number tested was non-Prime. Since there are only 336000 entries in the array that means that 83.5% of the time while generating the original array I could have stopped after calculating the second value.&lt;/p&gt;

&lt;p&gt;This was a longer write up than I originally expected, but it was a rather involved problem that benefited greatly from optimization.&lt;/p&gt;</content></entry>
 <entry>
  <title type="text">A 2012 blog post</title>
  <link rel="alternate" href="http://www.example.com/blog/2012/01/01/a-2012-blog-post/?utm_source=all&amp;utm_medium=Atom" />
  <id>urn:http-www-example-com:-blog-2012-01-01-a-2012-blog-post</id>
  <published>2012-01-01T08:00:00Z</published>
  <updated>2012-01-01T08:00:00Z</updated>
  <author>
   <name>The Unknown Author</name></author>
  <content type="html">
&lt;p&gt;Here is an example blog post.&lt;/p&gt;

&lt;p&gt;Everything after this paragraph &amp;ldquo;after the break&amp;rdquo;. On index pages and Atom feeds, it will become &amp;ldquo;Continue reading&amp;hellip;&amp;rdquo;, if you configure them to include only the summary &amp;ldquo;blurb&amp;rdquo; before the break.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;some code&lt;/code&gt;&lt;/pre&gt;
&lt;!-- more--&gt;

&lt;p&gt;Here&amp;rsquo;s some &lt;a href="http://bullshitipsum.com/?paragraphs=2"&gt;Bullshit Ipsum&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;test test&lt;/p&gt;

&lt;div class="figure"&gt;&lt;img src="192.168.1.74:3000/blog/img/ProjectEular-27-Mathematica01.png" alt="alt text" title="Mathematica" /&gt;
 &lt;p class="caption"&gt;alt text&lt;/p&gt;&lt;/div&gt;

&lt;p&gt;new test&lt;/p&gt;

&lt;p&gt;Addelivery integrate ecologies e-markets standards-compliant utilize technologies aggregate addelivery viral&amp;mdash;communities dynamic functionalities. Mindshare engineer viral A-list: cross-platform remix engage social cross-media social innovate distributed matrix experiences monetize utilize innovative. Action-items transition recontextualize sexy Cluetrain envisioneer, &amp;ldquo;vortals communities evolve technologies sexy methodologies.&amp;rdquo; Enhance grow compelling iterate architect matrix plug-and-play reinvent scale, distributed incentivize, extend.&lt;/p&gt;

&lt;p&gt;Revolutionary proactive. Target; envisioneer e-services sticky robust morph users methodologies, markets content supply-chains, granular monetize reinvent harness initiatives. Plug-and-play productize vortals integrate compelling aggregate, user-contributed, integrate web-enabled grow extend mindshare, repurpose world-class harness next-generation eyeballs solutions blogospheres extend. Rss-capable methodologies, &amp;ldquo;vortals vertical,&amp;rdquo; synthesize real-time user-contributed impactful utilize architect deploy ROI redefine design proactive strategic user-centric.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s a footnote&lt;sup&gt;&lt;a href="#2012-01-01-a-2012-blog-post-footnote-1-definition" name="2012-01-01-a-2012-blog-post-footnote-1-return"&gt;1&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;

&lt;h2 id="code-blocks"&gt;Code blocks&lt;/h2&gt;

&lt;p&gt;Frog optionally uses &lt;a href="http://pygments.org/"&gt;Pygments&lt;/a&gt; if it&amp;rsquo;s installed to do syntax highlighting. In your markdown using backtick code blocks you can specify a language:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;```language
some racket code
```&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That name is given to Pygments as the lexer to use.&lt;/p&gt;

&lt;p&gt;For example this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;```js
/**
 * Some JavaScript
 */
function foo()
{
    if (counter &amp;lt;= 10)
        return;
    // it works!
```&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Yields this:&lt;/p&gt;

&lt;div class="brush: js"&gt;
 &lt;pre&gt;&lt;code&gt;/**
 * Some JavaScript
 */
function foo()
{
    if (counter &amp;lt;= 10)
        return;
    // it works!&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;And this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;```racket
#lang racket
;; Finds Racket sources in all subdirs
(for ([path (in-directory)])
  (when (regexp-match? #rx"[.]rkt$" path)
    (printf "source file: ~a\n" path)))
(symbol-&amp;gt;string 'foo)
```&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Yields this:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;pre&gt;&lt;code&gt;#lang racket
;; Finds Racket sources in all subdirs
(for ([path (in-directory)])
  (when (regexp-match? #rx"[.]rkt$" path)
    (printf "source file: ~a\n" path)))
(symbol-&amp;gt;string 'foo)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Notice that, for Racket, symbols with unambiguous documentation (provided by one library, or provided by several where one is &lt;code&gt;racket&lt;/code&gt; or &lt;code&gt;racket/base&lt;/code&gt;) are links to that documentation.&lt;/p&gt;

&lt;p&gt;This also works outside fenced code blocks, for symbols in backticks immediately followed by &lt;code&gt;[racket]&lt;/code&gt;. Example: &lt;code&gt;&lt;a href="http://docs.racket-lang.org/reference/Writing.html#(def._((quote._~23~25kernel)._printf))" style="color: inherit"&gt;printf&lt;/a&gt;&lt;/code&gt;. This isn&amp;rsquo;t official Markdown; it&amp;rsquo;s simply a pun on link syntax and fenced code block languages. This is similar to using &lt;code&gt;@racket[printf]&lt;/code&gt; in Scribble.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;&lt;a href="http://docs.racket-lang.org/reference/symbols.html#(def._((quote._~23~25kernel)._symbol-~3estring))" style="color: inherit"&gt;symbol-&amp;gt;string&lt;/a&gt;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Here is a lambda: λ.&lt;/p&gt;

&lt;p&gt;Here is a lambda in code backticks: &lt;code&gt;λ&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;And here in indented code block:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(λ () #t)&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And here in fenced code block, no lang specified:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(λ () #t)&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And here in fenced code block, lang = &lt;code&gt;racket&lt;/code&gt;:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;pre&gt;&lt;code&gt;(λ () #t)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;And here in fenced code block, lang = &lt;code&gt;scheme&lt;/code&gt;:&lt;/p&gt;

&lt;div class="brush: scheme"&gt;
 &lt;pre&gt;&lt;code&gt;(λ () #t)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Here&amp;rsquo;s a simple &lt;code&gt;for&lt;/code&gt; macro, written in &lt;a href="http://docs.racket-lang.org/reference/stx-patterns.html"&gt;Racket&lt;/a&gt;:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;pre&gt;&lt;code&gt;(define-syntax-rule (for (x e1) e2)
  (for-each (λ (x) e2) e1))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The end.&lt;/p&gt;

&lt;div class="footnotes"&gt;
 &lt;ol&gt;
  &lt;li id="2012-01-01-a-2012-blog-post-footnote-1-definition" class="footnote-definition"&gt;
   &lt;p&gt;Footnote definition.&amp;nbsp;&lt;a href="#2012-01-01-a-2012-blog-post-footnote-1-return"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;</content></entry></feed>