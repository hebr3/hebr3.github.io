<!DOCTYPE html>
<html lang="en" class="gridded">
    <head>
        <meta charset="utf-8">
        <meta name="generator" content="Racket 6.8 + Pollen 1.1.1266.881">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Project Euler with Haskell</title>
        <link rel="stylesheet" href="/styles.css" media="screen">
                <script type="text/javascript"
                  src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
                </script>
                <script type="text/x-mathjax-config">
                  MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});
                </script>
                <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/styles/default.min.css">
                <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.10.0/highlight.min.js"></script>
                <script>hljs.initHighlightingOnLoad()</script>
    </head>
    <body>
        <header class="main">
            <p><a href="/index.html" class="home">Henry Brooks</a></p>
            <nav>
                <ul>
                    <li><a href="/topics.html">Topics</a></li>
                    <li><a href="/about.html">About</a></li>
                </ul>
            </nav>
        </header>

        <article>
            <header>
                <h1>Project Euler with Haskell</h1>
                <p>Scribbled <a href="/posts\project-euler-with-haskell.html" class="permlink"><time datetime="2015-10-03">Saturday, October 3rd, 2015</time></a>

                &middot;&nbsp;<a class="pdf" href="project-euler-with-haskell.pdf">PDF</a>&nbsp;
                &middot;&nbsp;<a href="/posts\project-euler-with-haskell.pollen.html" class="source-link">&loz;&nbsp;Pollen&nbsp;Source</a></p>
                <ul>
                <li><a href="/topics.html#Project Euler">#Project Euler</a></li><li><a href="/topics.html#Haskell">#Haskell</a></li></ul>
            </header>

<p>Teaching Algebra A has been more of a slog then I was expecting and I’ve been feeling like I need to stretch myself before I get bogged down in teaching this year. I enjoyed working on Project Euler problems last year and while looking over the site again I stumbled over the haskell programming language.</p><p>Looking over the Haskell syntax I see a lot of design decisions that align with my mathematic background. I feel that the list comprehensions and mapping functions for lists have a strong mathematical foundation and I think that I will be able to pick up the language quickly.</p><p>I’m going to try to work through all of the Project Euler problems I completed with Mathematic last year and see if the process is easier or at least clearer this time around.</p><h2>Problem 1</h2><p>This problem, and it’s solution, really highlight why I wanted to try my hand at learning Haskell. The list comprehension syntax I use in this solution are nearly identical to the mathematical notation I would use to discribe this problems solution mathematically. We create a set of natural numbers less than 1000 that are congruent to 0 mod 3 or 5, then we sum the elements of the set. $$\mathbf{S} = \left \{x \;|\; x \in \mathbb{N}, \; x \lt 1000, \; x \equiv 0 \; (\textbf{mod}\; 3) \vee x \equiv 0 (\textbf{mod}\; 5)\right \}$$ $$\sum x ,  x \in \mathbf{S}$$</p><div class="filebox"><div class="filename" decode="exclude">ProjectEuler1.hs</div><div class="highlight"><pre><code>main :: IO ()
main = do
    putStrLn "ProjectEuler.net"
    putStrLn "Problem1 - Sum of the natural numbers below 1000 that are multiplies of 3 or 5"
    print problem1

--Sum of the natural numbers below 1000 that are multiplies of 3 or 5
problem1 = sum [x | x &lt;- [1..999], mod x 3 == 0 || mod x 5 == 0]</code></pre></div></div><p>My solution ends up using the <code>x&lt;-[1..999]</code> instead of <code>x&lt;-[1..], x &lt; 1000</code> because Haskell’s methodology doesn’t align perfectly the math notation. Specifically it keep checking numbers, even after 1000, to see if $$x \lt 1000, \; x \equiv 0 \; (\textbf{mod}\; 3) \vee x \equiv 0 (\textbf{mod}\; 5)$$ I could still make use of <a href="https://en.wikipedia.org/wiki/Lazy_evaluation#Working_with_infinite_data_structures">Haskell’s infinite list</a> <code>[1..]</code> however, I would need to add <code>sum (takeWhile (&lt;1000) [x | x &lt;-[1..], ...])</code> to only take <code>x</code> values less than 1000. This is all a result of <a href="https://en.wikipedia.org/wiki/Lazy_evaluation">lazy evaluation</a> and is a little more complicated than I can properly explain.</p><p>Still the solution works well and I feel that it matches how I would approach this problem from a math perspective if I was doing this problem on paper.</p><p>Caveat: I know this problem can also be solved using <a href="https://www.wolframalpha.com/input/?i=(sum+3i+from+i%3D0+to+(999%2F3))+%2B+(sum+5j+from+j%3D0+to+(999%2F5))+-+(sum+15k+from+k%3D0+to+(999%2F15))">sum’s</a> by modifing the equation for <a href="https://en.wikipedia.org/wiki/1_%2B_2_%2B_3_%2B_4_%2B_%E2%8B%AF#Partial_sums">partial sums</a>.</p><p>$$\sum_{i=0}^{\left\lfloor\frac{999}{3}\right\rfloor} 3i +<br/>  \sum_{j=0}^{\left\lfloor\frac{999}{5}\right\rfloor} 5j -<br/>  \sum_{k=0}^{\left\lfloor\frac{999}{15}\right\rfloor} 15k $$</p><h2>Problem 2</h2><p>I didn’t use the standard Haskell version of the Fibonacci equation for this problem.</p><div class="filebox"><div class="filename" decode="exclude"></div><div class="highlight"><pre><code>fib 0 = 1
fib 2 = 1
fib n = fib (n-1) + fib (n-2)</code></pre></div></div><p>This version will blow up in space and time requirements for large values of <code>n</code> and is generally less efficient.</p><p>I instead went with an <a href="https://www.ics.uci.edu/~eppstein/161/960109.html">iterative version</a> of fibonacci that takes n steps to calcuate <code>fib n</code>.</p><p>There are some other versions of Fibonacci that bring the space and time complexity down further using recurrent patterns however, I felt like this code was good enough for my purposes here.</p><div class="filebox"><div class="filename" decode="exclude">ProjectEuler2.hs</div><div class="highlight"><pre><code>main :: IO ()
main = do
    putStrLn "ProjectEuler.net"

    putStrLn "\nProblem2 - Sum of the even Fibonacci numbers less than 4,000,000"
    print problem2

--Sum of the even Fibonacci numbers less than 4,000,000
problem2 = sum [fib x | x &lt;- [1..100], mod (fib x) 2 == 0, (fib x) &lt; 4000000]

fib n = fib_iter 1 0 n

fib_iter a b 0 = b
fib_iter a b count = fib_iter (a + b) a (count - 1)</code></pre></div></div><p>While working on this problem I also found out that I could have had Haskell to generate an infinite list of fibonacci numbers using this code </p><div class="filebox"><div class="filename" decode="exclude"></div><div class="highlight"><pre><code>fibs = 0 : 1 : zipWith (+) fibs (tail fibs)</code></pre></div></div><p>I’m finding that infinite lists are one of the aspects of Haskell that are really intriguing to me. They seem to provide a bridge between mathematics and programming that I am interested in exploring further.</p>
        </article>
        <footer class="main">
            <ul>
                <li><a href="mailto:brook057@cougars.csusm.edu">brook057@cougars.csusm.edu</a></li>
                <li>Source code on <a href="https://github.com/hebr3/hebr3.github.io"> <b>Github</b></a></li>
            </ul>
        </footer>
    </body>
</html>