<!DOCTYPE html>
<html lang="en" class="gridded">
    <head>
        <meta charset="utf-8">
        <meta name="generator" content="Racket 6.8 + Pollen 1.1.1266.881">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Project Euler problems 1 and 2, with Haskell</title>
        <link rel="stylesheet" href="/styles.css" media="screen">
                <script type="text/javascript"
                  src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
                </script>
                <script type="text/x-mathjax-config">
                  MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});
                </script>
    </head>
    <body>
        <header class="main">
            <p><a href="/index.html" class="home">Henry Brooks</a></p>
            <nav>
                <ul>
                    <li><a href="/topics.html">Topics</a></li>
                    <li><a href="/about.html">About</a></li>
                </ul>
            </nav>
        </header>

        <article>
            <header>
                <h1>Project Euler problems 1 and 2, with Haskell</h1>
                <p>Scribbled <a href="/posts\project-euler-with-haskell.html" class="permlink"><time datetime="2015-10-03">Saturday, October 3rd, 2015</time></a>
                </p>
                <ul>
                <li><a href="/topics.html#Project Euler">#Project Euler</a></li><li><a href="/topics.html#Haskell">#Haskell</a></li></ul>
            </header>

<p>Teaching Algebra A has been more of a slog then I was expecting and I’ve been feeling like I need to stretch myself before I get bogged down in teaching this year. I enjoyed working on Project Euler problems last year and while looking over the site again I stumbled over the haskell programming language.</p><p>Looking over the Haskell syntax I see a lot of design decisions that align with my mathematic background. I feel that the list comprehensions and mapping functions for lists have a strong mathematical foundation and I think that I will be able to pick up the language quickly.</p><p>I’m going to try to work through all of the Project Euler problems I completed with Mathematic last year and see if the process is easier or at least clearer this time around.</p><h2>Problem 1</h2><p>This problem, and it’s solution, really highlight why I wanted to try my hand at learning Haskell. The list comprehension syntax I use in this solution are nearly identical to the mathematical notation I would use to discribe this problems solution mathematically. We create a set of natural numbers less than 1000 that are congruent to 0 mod 3 or 5, then we sum the elements of the set. $$\mathbf{S} = \left \{x \;|\; x \in \mathbb{N}, \; x \lt 1000, \; x \equiv 0 \; (\textbf{mod}\; 3) \vee x \equiv 0 (\textbf{mod}\; 5)\right \}$$ $$\sum x ,  x \in \mathbf{S}$$</p><div class="filebox"><div class="filename" decode="exclude">ProjectEuler1.hs</div><div class="highlight"><table class="sourcetable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="source"><pre><span></span><span class="nf">main</span> <span class="ow">::</span> <span class="kt">IO</span> <span class="nb">()</span>
<span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">putStrLn</span> <span class="s">"ProjectEuler.net"</span>
    <span class="n">putStrLn</span> <span class="s">"Problem1 - Sum of the natural numbers below 1000 that are multiplies of 3 or 5"</span>
    <span class="n">print</span> <span class="n">problem1</span>

<span class="c1">--Sum of the natural numbers below 1000 that are multiplies of 3 or 5</span>
<span class="nf">problem1</span> <span class="ow">=</span> <span class="n">sum</span> <span class="p">[</span><span class="n">x</span> <span class="o">|</span> <span class="n">x</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">999</span><span class="p">],</span> <span class="n">mod</span> <span class="n">x</span> <span class="mi">3</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">mod</span> <span class="n">x</span> <span class="mi">5</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span>
</pre></div>
</td></tr></tbody></table></div></div><p>My solution ends up using the <code>x&lt;-[1..999]</code> instead of <code>x&lt;-[1..], x &lt; 1000</code> because Haskell’s methodology doesn’t align perfectly the math notation. Specifically it keep checking numbers, even after 1000, to see if $$x \lt 1000, \; x \equiv 0 \; (\textbf{mod}\; 3) \vee x \equiv 0 (\textbf{mod}\; 5)$$ I could still make use of <a href="https://en.wikipedia.org/wiki/Lazy_evaluation#Working_with_infinite_data_structures">Haskell’s infinite list</a> <code>[1..]</code> however, I would need to add <code>sum (takeWhile (&lt;1000) [x | x &lt;-[1..], ...])</code> to only take <code>x</code> values less than 1000. This is all a result of <a href="https://en.wikipedia.org/wiki/Lazy_evaluation">lazy evaluation</a> and is a little more complicated than I can properly explain.</p><p>Still the solution works well and I feel that it matches how I would approach this problem from a math perspective if I was doing this problem on paper.</p><p>Caveat: I know this problem can also be solved using <a href="https://www.wolframalpha.com/input/?i=(sum+3i+from+i%3D0+to+(999%2F3))+%2B+(sum+5j+from+j%3D0+to+(999%2F5))+-+(sum+15k+from+k%3D0+to+(999%2F15))">sum’s</a> by modifing the equation for <a href="https://en.wikipedia.org/wiki/1_%2B_2_%2B_3_%2B_4_%2B_%E2%8B%AF#Partial_sums">partial sums</a>.</p><p>$$\sum_{i=0}^{\left\lfloor\frac{999}{3}\right\rfloor} 3i +<br/>  \sum_{j=0}^{\left\lfloor\frac{999}{5}\right\rfloor} 5j -<br/>  \sum_{k=0}^{\left\lfloor\frac{999}{15}\right\rfloor} 15k $$</p><h2>Problem 2</h2><p>I didn’t use the standard Haskell version of the Fibonacci equation for this problem.</p><div class="filebox"><div class="filename" decode="exclude"></div><div class="highlight"><table class="sourcetable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="source"><pre><span></span><span class="nf">fib</span> <span class="mi">0</span> <span class="ow">=</span> <span class="mi">1</span>
<span class="nf">fib</span> <span class="mi">2</span> <span class="ow">=</span> <span class="mi">1</span>
<span class="nf">fib</span> <span class="n">n</span> <span class="ow">=</span> <span class="n">fib</span> <span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">fib</span> <span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</td></tr></tbody></table></div></div><p>This version will blow up in space and time requirements for large values of <code>n</code> and is generally less efficient.</p><p>I instead went with an <a href="https://www.ics.uci.edu/~eppstein/161/960109.html">iterative version</a> of fibonacci that takes n steps to calcuate <code>fib n</code>.</p><p>There are some other versions of Fibonacci that bring the space and time complexity down further using recurrent patterns however, I felt like this code was good enough for my purposes here.</p><div class="filebox"><div class="filename" decode="exclude">ProjectEuler2.hs</div><div class="highlight"><table class="sourcetable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14</pre></div></td><td class="code"><div class="source"><pre><span></span><span class="nf">main</span> <span class="ow">::</span> <span class="kt">IO</span> <span class="nb">()</span>
<span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">putStrLn</span> <span class="s">"ProjectEuler.net"</span>

    <span class="n">putStrLn</span> <span class="s">"</span><span class="se">\n</span><span class="s">Problem2 - Sum of the even Fibonacci numbers less than 4,000,000"</span>
    <span class="n">print</span> <span class="n">problem2</span>

<span class="c1">--Sum of the even Fibonacci numbers less than 4,000,000</span>
<span class="nf">problem2</span> <span class="ow">=</span> <span class="n">sum</span> <span class="p">[</span><span class="n">fib</span> <span class="n">x</span> <span class="o">|</span> <span class="n">x</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">100</span><span class="p">],</span> <span class="n">mod</span> <span class="p">(</span><span class="n">fib</span> <span class="n">x</span><span class="p">)</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">fib</span> <span class="n">x</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">4000000</span><span class="p">]</span>

<span class="nf">fib</span> <span class="n">n</span> <span class="ow">=</span> <span class="n">fib_iter</span> <span class="mi">1</span> <span class="mi">0</span> <span class="n">n</span>

<span class="nf">fib_iter</span> <span class="n">a</span> <span class="n">b</span> <span class="mi">0</span> <span class="ow">=</span> <span class="n">b</span>
<span class="nf">fib_iter</span> <span class="n">a</span> <span class="n">b</span> <span class="n">count</span> <span class="ow">=</span> <span class="n">fib_iter</span> <span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">)</span> <span class="n">a</span> <span class="p">(</span><span class="n">count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</td></tr></tbody></table></div></div><p>While working on this problem I also found out that I could have had Haskell to generate an infinite list of fibonacci numbers using this code </p><div class="filebox"><div class="filename" decode="exclude"></div><div class="highlight"><table class="sourcetable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="source"><pre><span></span><span class="nf">fibs</span> <span class="ow">=</span> <span class="mi">0</span> <span class="kt">:</span> <span class="mi">1</span> <span class="kt">:</span> <span class="n">zipWith</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="n">fibs</span> <span class="p">(</span><span class="n">tail</span> <span class="n">fibs</span><span class="p">)</span>
</pre></div>
</td></tr></tbody></table></div></div><p>I’m finding that infinite lists are one of the aspects of Haskell that are really intriguing to me. They seem to provide a bridge between mathematics and programming that I am interested in exploring further.</p>
        </article>
        <footer class="main">
            <ul>
                <li><a href="mailto:brook057@cougars.csusm.edu">brook057@cougars.csusm.edu</a></li>
                <li>Source code on <a href="https://github.com/hebr3/hebr3.github.io"><b>Github</b></a></li>
            </ul>
        </footer>
    </body>
</html>