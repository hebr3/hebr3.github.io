((3) 0 () 2 ((p+ #"C:\\Users\\Henry\\Documents\\blog\\_src\\posts\\2015-04-11-20-Project-projecteuler-27.md" . windows) (p+ #"C:\\Users\\Henry\\Documents\\blog\\_src\\posts\\2012-01-01-a-2012-blog-post.md" . windows)) () (h ! (equal) ((p+ #"C:\\Users\\Henry\\Documents\\blog\\_src\\posts\\2012-01-01-a-2012-blog-post.md" . windows) f post (u . "A 2012 blog post") (? . 1) 1483765356 (p+ #"C:\\Users\\Henry\\Documents\\blog\\blog/2012/01/01/a-2012-blog-post/index.html" . windows) "/blog/2012/01/01/a-2012-blog-post/" (u . "2012-01-01T00:00:00") #f (? . 0) (c (u . "foo") c (u . "bar") c (u . "tag with spaces") c (u . "baz")) (u . "\n<p>Here is an example blog post.</p>\n\n<p>Everything after this paragraph &ldquo;after the break&rdquo;. On index pages and Atom feeds, it will become &ldquo;Continue reading&hellip;&rdquo;, if you configure them to include only the summary &ldquo;blurb&rdquo; before the break.</p>\n\n<pre><code>some code</code></pre>") #t (u . "\n<p>Here is an example blog post.</p>\n\n<p>Everything after this paragraph &ldquo;after the break&rdquo;. On index pages and Atom feeds, it will become &ldquo;Continue reading&hellip;&rdquo;, if you configure them to include only the summary &ldquo;blurb&rdquo; before the break.</p>\n\n<pre><code>some code</code></pre>\n<!-- more-->\n\n<p>Here&rsquo;s some <a href=\"http://bullshitipsum.com/?paragraphs=2\">Bullshit Ipsum</a>.</p>\n\n<p>test test</p>\n\n<div class=\"figure\"><img src=\"192.168.1.74:3000/blog/img/ProjectEular-27-Mathematica01.png\" alt=\"alt text\" title=\"Mathematica\" />\n <p class=\"caption\">alt text</p></div>\n\n<p>new test</p>\n\n<p>Addelivery integrate ecologies e-markets standards-compliant utilize technologies aggregate addelivery viral&mdash;communities dynamic functionalities. Mindshare engineer viral A-list: cross-platform remix engage social cross-media social innovate distributed matrix experiences monetize utilize innovative. Action-items transition recontextualize sexy Cluetrain envisioneer, &ldquo;vortals communities evolve technologies sexy methodologies.&rdquo; Enhance grow compelling iterate architect matrix plug-and-play reinvent scale, distributed incentivize, extend.</p>\n\n<p>Revolutionary proactive. Target; envisioneer e-services sticky robust morph users methodologies, markets content supply-chains, granular monetize reinvent harness initiatives. Plug-and-play productize vortals integrate compelling aggregate, user-contributed, integrate web-enabled grow extend mindshare, repurpose world-class harness next-generation eyeballs solutions blogospheres extend. Rss-capable methodologies, &ldquo;vortals vertical,&rdquo; synthesize real-time user-contributed impactful utilize architect deploy ROI redefine design proactive strategic user-centric.</p>\n\n<p>Here&rsquo;s a footnote<sup><a href=\"#2012-01-01-a-2012-blog-post-footnote-1-definition\" name=\"2012-01-01-a-2012-blog-post-footnote-1-return\">1</a></sup>.</p>\n\n<h2 id=\"code-blocks\">Code blocks</h2>\n\n<p>Frog optionally uses <a href=\"http://pygments.org/\">Pygments</a> if it&rsquo;s installed to do syntax highlighting. In your markdown using backtick code blocks you can specify a language:</p>\n\n<pre><code>```language\nsome racket code\n```</code></pre>\n\n<p>That name is given to Pygments as the lexer to use.</p>\n\n<p>For example this:</p>\n\n<pre><code>```js\n/**\n * Some JavaScript\n */\nfunction foo()\n{\n    if (counter &lt;= 10)\n        return;\n    // it works!\n```</code></pre>\n\n<p>Yields this:</p>\n\n<div class=\"brush: js\">\n <pre><code>/**\n * Some JavaScript\n */\nfunction foo()\n{\n    if (counter &lt;= 10)\n        return;\n    // it works!</code></pre></div>\n\n<p>And this:</p>\n\n<pre><code>```racket\n#lang racket\n;; Finds Racket sources in all subdirs\n(for ([path (in-directory)])\n  (when (regexp-match? #rx\"[.]rkt$\" path)\n    (printf \"source file: ~a\\n\" path)))\n(symbol-&gt;string 'foo)\n```</code></pre>\n\n<p>Yields this:</p>\n\n<div class=\"brush: racket\">\n <pre><code>#lang racket\n;; Finds Racket sources in all subdirs\n(for ([path (in-directory)])\n  (when (regexp-match? #rx\"[.]rkt$\" path)\n    (printf \"source file: ~a\\n\" path)))\n(symbol-&gt;string 'foo)</code></pre></div>\n\n<p>Notice that, for Racket, symbols with unambiguous documentation (provided by one library, or provided by several where one is <code>racket</code> or <code>racket/base</code>) are links to that documentation.</p>\n\n<p>This also works outside fenced code blocks, for symbols in backticks immediately followed by <code>[racket]</code>. Example: <code><a href=\"http://docs.racket-lang.org/reference/Writing.html#(def._((quote._~23~25kernel)._printf))\" style=\"color: inherit\">printf</a></code>. This isn&rsquo;t official Markdown; it&rsquo;s simply a pun on link syntax and fenced code block languages. This is similar to using <code>@racket[printf]</code> in Scribble.</p>\n\n<p><code><a href=\"http://docs.racket-lang.org/reference/symbols.html#(def._((quote._~23~25kernel)._symbol-~3estring))\" style=\"color: inherit\">symbol-&gt;string</a></code>.</p>\n\n<p>Here is a lambda: λ.</p>\n\n<p>Here is a lambda in code backticks: <code>λ</code>.</p>\n\n<p>And here in indented code block:</p>\n\n<pre><code>(λ () #t)</code></pre>\n\n<p>And here in fenced code block, no lang specified:</p>\n\n<pre><code>(λ () #t)</code></pre>\n\n<p>And here in fenced code block, lang = <code>racket</code>:</p>\n\n<div class=\"brush: racket\">\n <pre><code>(λ () #t)</code></pre></div>\n\n<p>And here in fenced code block, lang = <code>scheme</code>:</p>\n\n<div class=\"brush: scheme\">\n <pre><code>(λ () #t)</code></pre></div>\n\n<p>Here&rsquo;s a simple <code>for</code> macro, written in <a href=\"http://docs.racket-lang.org/reference/stx-patterns.html\">Racket</a>:</p>\n\n<div class=\"brush: racket\">\n <pre><code>(define-syntax-rule (for (x e1) e2)\n  (for-each (λ (x) e2) e1))</code></pre></div>\n\n<p>The end.</p>\n\n<div class=\"footnotes\">\n <ol>\n  <li id=\"2012-01-01-a-2012-blog-post-footnote-1-definition\" class=\"footnote-definition\">\n   <p>Footnote definition.&nbsp;<a href=\"#2012-01-01-a-2012-blog-post-footnote-1-return\">↩</a></p></li></ol></div>")) ((p+ #"C:\\Users\\Henry\\Documents\\blog\\_src\\posts\\2015-04-11-20-Project-projecteuler-27.md" . windows) f post (u . "20% Project update") (? . 0) 1483764573 (p+ #"C:\\Users\\Henry\\Documents\\blog\\blog/2015/04/11/20-project-update/index.html" . windows) "/blog/2015/04/11/20-project-update/" (u . "2015-04-11T18:53:16") (? . 1) #f (c (u . "20% Project")) (u . "\n<p>Euler discovered the remarkable quadratic formula:</p>\n\n<p>n² + n + 41</p>\n\n<p>It turns out that the formula will produce 40 primes for the consecutive values n = 0 to 39. However, when n = 40, 402 + 40 + 41 = 40(40 + 1) + 41 is divisible by 41, and certainly when n = 41, 41² + 41 + 41 is clearly divisible by 41.</p>\n\n<p>The incredible formula n² − 79n + 1601 was discovered, which produces 80 primes for the consecutive values n = 0 to 79. The product of the coefficients, −79 and 1601, is −126479.</p>\n\n<p>Considering quadratics of the form:</p>\n\n<p>n² + an + b, where |a| &lt; 1000 and |b| &lt; 1000</p>\n\n<p>where |n| is the modulus/absolute value of n e.g. |11| = 11 and |−4| = 4</p>\n\n<p>Find the product of the coefficients, a and b, for the quadratic expression that produces the maximum number of primes for consecutive values of n, starting with n = 0.</p>\n\n<p>From Project Euler</p>\n\n<hr />\n\n<p>Initially I planned to tackle this problem from a strictly brute force perspective. I have found that working on a simple solution to a problem usually gives me insights to more elegant solutions.</p>\n\n<p>Therefore I figured that the most straight forward and inelegant method was to produce a 1999 by 1999 array with individual elements of the array corresponding to the maximum number of consecutive primes generated by that combination of a and b.</p>\n\n<p>Thus the initial element of the array in position |1,1| would be the maximum number of consecutive primes generated by n² + (&ndash;999)n + (&ndash;999), and the final position of |1999,1999| would be n² + (999)n + (999).</p>\n\n<p>With this plan in mind I tried to think up a quick way to calculate the maximum number of consecutive primes for a given a and b.</p>\n\n<p>I started by having Mathematica generate the first 101 values from the example given in the problem by using a=1 and b=41.</p>\n\n<p>ProjectEuler-Mathematica01</p>\n\n<p>I then used PrimeQ to test whether each value was prime.</p>\n\n<p>ProjectEuler-Mathematica02</p>\n\n<p>Then used Boole to convert these true false values to 0&rsquo;s and 1&rsquo;s.</p>\n\n<p>ProjectEuler-Mathematica03</p>\n\n<p>And finally FirstPosition to find the first false in the list.</p>\n\n<p>ProjectEuler-Mathematica04</p>\n\n<p>Note that the answer of 41 corresponds to the 39 primes listed in the example since this method doesn&rsquo;t count the primes from 0&ndash;39 but from 1&ndash;40 and it found a non-Prime number in position 41.</p>\n\n<p>So&hellip;</p>\n\n<p>This method is horribly inelegant, however it also does work so it&rsquo;s time to see if I can use this method to generate the 1999 by 1999 array I initially planned for.</p>\n\n<p>I begin by trying a smaller array and seeing if my method works.</p>\n\n<p>ProjectEuler-Mathematica05</p>\n\n<p>Note that this entry should be much larger as it displays a 51 by 51 array of values.</p>\n\n<p>To find the maximum element of this array I then use the Position and Max commands. Position gives the location in an array of a specified value, and Max gives the largest element of the array.</p>\n\n<p>ProjectEuler-Mathematica06</p>\n\n<p>Since we are counting up from 0 we have now found that the Maximum number of consecutive primes is generated with a=1 and b=41 which matches the example.</p>\n\n<p>One area of concern going forward is that it takes 0.655204 secs for Mathematica to create the 51 by 51 array I used above. Since a 1999 by 1999 array is nearly 1600% larger than a 50 by 50 array that means that generating a 1999 by 1999 array should take at least 17 minutes and 28.33 second. Most likely longer considering that the edges of the array will be dealing with a and b values greater than 900.</p>\n\n<p>Still I have free time and I&rsquo;m not paying for processing time so we might as well go forward and see how long it takes.</p>\n\n<p>ProjectEuler-Mathematica07</p>\n\n<p>So 21 minutes and 14 seconds later we have our array and can try to find the Maximum number of consecutive primes.</p>\n\n<p>ProjectEuler-Mathematica08</p>\n\n<p>And we have a max at |939,1971|, so 939&ndash;1000=&ndash;61 and 1971&ndash;1000=971 are are a and b values.</p>\n\n<p>a*b=&ndash;61*971=&ndash;59231</p>\n\n<p>And we thus have our answer for Problem 27.</p>\n\n<p>Now how could we have improved this process.</p>\n\n<p>We could start by recognizing that b has to be a prime number. It was only after I had finished this problem that I realized that since n starts at 0 the first element will always be 0*0 + a*0 + b. Since there are 168 primes less than 1000 that means I only needed 168 rows instead of 1999.</p>\n\n<p>A 1999 by 168 array is 8.4% the size of a 1999 by 1999 array and only took Mathematica 1 minute and 56 seconds to calculate.</p>\n\n<p>ProjectEuler-Mathematica09</p>\n\n<p>A larger time sink is that I am actually calculating out the first 100 n values for every combination of a and b tested. Thus even if the second value calculated is non-Prime I still waste time evaluating the next 98 values.</p>\n\n<p>Using the following code I can just check if the n values are prime and stop when a non-Prime is found.</p>\n\n<p>ProjectEuler-Mathematica10</p>\n\n<p>To better understand how much time this saves, I calculated a 50 by 50 array using the old method and the new method and had Mathematica generate an ArrayPlot to save space.</p>\n\n<p>ProjectEuler-Mathematica11</p>\n\n<p>The second method took 6.1% of the time taken by the first method.</p>\n\n<p>Using both methods together the entire process of generating the 1999 by 168 array takes 10 seconds.</p>\n\n<p>ProjectEuler-Mathematica12</p>\n\n<p>I haven&rsquo;t looked into it, but I suspect that I could similarly shave a couple of seconds off of the total running time by finding some trick for picking a values.</p>\n\n<p>Conclusion</p>\n\n<p>I started by creating a rather inelegant method for finding the number of consecutive primes generated on a 1999 by 1999 matrix. This method took 21 minutes and 14 seconds.</p>\n\n<p>I next examined the problem more closely and found areas that could be refined so that I found that same solution in 10 seconds.</p>\n\n<p>I&rsquo;m confident that the majority of the improvement in performance came from optimizing the operation that found the number of consecutive primes.</p>\n\n<p>ProjectEuler-Mathematica13</p>\n\n<p>Using the above code I found that 280607 times the second number tested was non-Prime. Since there are only 336000 entries in the array that means that 83.5% of the time while generating the original array I could have stopped after calculating the second value.</p>\n\n<p>This was a longer write up than I originally expected, but it was a rather involved problem that benefited greatly from optimization.</p>") #f (u . "\n<p>Euler discovered the remarkable quadratic formula:</p>\n\n<p>n² + n + 41</p>\n\n<p>It turns out that the formula will produce 40 primes for the consecutive values n = 0 to 39. However, when n = 40, 402 + 40 + 41 = 40(40 + 1) + 41 is divisible by 41, and certainly when n = 41, 41² + 41 + 41 is clearly divisible by 41.</p>\n\n<p>The incredible formula n² − 79n + 1601 was discovered, which produces 80 primes for the consecutive values n = 0 to 79. The product of the coefficients, −79 and 1601, is −126479.</p>\n\n<p>Considering quadratics of the form:</p>\n\n<p>n² + an + b, where |a| &lt; 1000 and |b| &lt; 1000</p>\n\n<p>where |n| is the modulus/absolute value of n e.g. |11| = 11 and |−4| = 4</p>\n\n<p>Find the product of the coefficients, a and b, for the quadratic expression that produces the maximum number of primes for consecutive values of n, starting with n = 0.</p>\n\n<p>From Project Euler</p>\n\n<hr />\n\n<p>Initially I planned to tackle this problem from a strictly brute force perspective. I have found that working on a simple solution to a problem usually gives me insights to more elegant solutions.</p>\n\n<p>Therefore I figured that the most straight forward and inelegant method was to produce a 1999 by 1999 array with individual elements of the array corresponding to the maximum number of consecutive primes generated by that combination of a and b.</p>\n\n<p>Thus the initial element of the array in position |1,1| would be the maximum number of consecutive primes generated by n² + (&ndash;999)n + (&ndash;999), and the final position of |1999,1999| would be n² + (999)n + (999).</p>\n\n<p>With this plan in mind I tried to think up a quick way to calculate the maximum number of consecutive primes for a given a and b.</p>\n\n<p>I started by having Mathematica generate the first 101 values from the example given in the problem by using a=1 and b=41.</p>\n\n<p>ProjectEuler-Mathematica01</p>\n\n<p>I then used PrimeQ to test whether each value was prime.</p>\n\n<p>ProjectEuler-Mathematica02</p>\n\n<p>Then used Boole to convert these true false values to 0&rsquo;s and 1&rsquo;s.</p>\n\n<p>ProjectEuler-Mathematica03</p>\n\n<p>And finally FirstPosition to find the first false in the list.</p>\n\n<p>ProjectEuler-Mathematica04</p>\n\n<p>Note that the answer of 41 corresponds to the 39 primes listed in the example since this method doesn&rsquo;t count the primes from 0&ndash;39 but from 1&ndash;40 and it found a non-Prime number in position 41.</p>\n\n<p>So&hellip;</p>\n\n<p>This method is horribly inelegant, however it also does work so it&rsquo;s time to see if I can use this method to generate the 1999 by 1999 array I initially planned for.</p>\n\n<p>I begin by trying a smaller array and seeing if my method works.</p>\n\n<p>ProjectEuler-Mathematica05</p>\n\n<p>Note that this entry should be much larger as it displays a 51 by 51 array of values.</p>\n\n<p>To find the maximum element of this array I then use the Position and Max commands. Position gives the location in an array of a specified value, and Max gives the largest element of the array.</p>\n\n<p>ProjectEuler-Mathematica06</p>\n\n<p>Since we are counting up from 0 we have now found that the Maximum number of consecutive primes is generated with a=1 and b=41 which matches the example.</p>\n\n<p>One area of concern going forward is that it takes 0.655204 secs for Mathematica to create the 51 by 51 array I used above. Since a 1999 by 1999 array is nearly 1600% larger than a 50 by 50 array that means that generating a 1999 by 1999 array should take at least 17 minutes and 28.33 second. Most likely longer considering that the edges of the array will be dealing with a and b values greater than 900.</p>\n\n<p>Still I have free time and I&rsquo;m not paying for processing time so we might as well go forward and see how long it takes.</p>\n\n<p>ProjectEuler-Mathematica07</p>\n\n<p>So 21 minutes and 14 seconds later we have our array and can try to find the Maximum number of consecutive primes.</p>\n\n<p>ProjectEuler-Mathematica08</p>\n\n<p>And we have a max at |939,1971|, so 939&ndash;1000=&ndash;61 and 1971&ndash;1000=971 are are a and b values.</p>\n\n<p>a*b=&ndash;61*971=&ndash;59231</p>\n\n<p>And we thus have our answer for Problem 27.</p>\n\n<p>Now how could we have improved this process.</p>\n\n<p>We could start by recognizing that b has to be a prime number. It was only after I had finished this problem that I realized that since n starts at 0 the first element will always be 0*0 + a*0 + b. Since there are 168 primes less than 1000 that means I only needed 168 rows instead of 1999.</p>\n\n<p>A 1999 by 168 array is 8.4% the size of a 1999 by 1999 array and only took Mathematica 1 minute and 56 seconds to calculate.</p>\n\n<p>ProjectEuler-Mathematica09</p>\n\n<p>A larger time sink is that I am actually calculating out the first 100 n values for every combination of a and b tested. Thus even if the second value calculated is non-Prime I still waste time evaluating the next 98 values.</p>\n\n<p>Using the following code I can just check if the n values are prime and stop when a non-Prime is found.</p>\n\n<p>ProjectEuler-Mathematica10</p>\n\n<p>To better understand how much time this saves, I calculated a 50 by 50 array using the old method and the new method and had Mathematica generate an ArrayPlot to save space.</p>\n\n<p>ProjectEuler-Mathematica11</p>\n\n<p>The second method took 6.1% of the time taken by the first method.</p>\n\n<p>Using both methods together the entire process of generating the 1999 by 168 array takes 10 seconds.</p>\n\n<p>ProjectEuler-Mathematica12</p>\n\n<p>I haven&rsquo;t looked into it, but I suspect that I could similarly shave a couple of seconds off of the total running time by finding some trick for picking a values.</p>\n\n<p>Conclusion</p>\n\n<p>I started by creating a rather inelegant method for finding the number of consecutive primes generated on a 1999 by 1999 matrix. This method took 21 minutes and 14 seconds.</p>\n\n<p>I next examined the problem more closely and found areas that could be refined so that I found that same solution in 10 seconds.</p>\n\n<p>I&rsquo;m confident that the majority of the improvement in performance came from optimizing the operation that found the number of consecutive primes.</p>\n\n<p>ProjectEuler-Mathematica13</p>\n\n<p>Using the above code I found that 280607 times the second number tested was non-Prime. Since there are only 336000 entries in the array that means that 83.5% of the time while generating the original array I could have stopped after calculating the second value.</p>\n\n<p>This was a longer write up than I originally expected, but it was a rather involved problem that benefited greatly from optimization.</p>"))))